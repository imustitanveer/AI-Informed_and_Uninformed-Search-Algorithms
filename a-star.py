import heapq
from copy import deepcopy

class PuzzleState:
    def __init__(self, board, g=0, parent=None):
        """
        Initialize a PuzzleState object with the given board state.

        Parameters:
            board (list of lists): Current state of the puzzle
            g (int): Cost to reach this state (default: 0)
            parent (PuzzleState): Reference to parent state (default: None)
        """
        self.board = board  # Current state of the puzzle
        self.g = g  # Cost to reach this state
        self.parent = parent  # Reference to parent state
        self.zero_pos = self.find_zero()  # Position of the empty tile
        self.h = 0  # Heuristic value (to be computed later)

    def find_zero(self):
        """
        Find the position of the empty tile (0) in the puzzle state.

        Returns:
            tuple: (i, j) coordinates of the empty tile
        """
        for i, row in enumerate(self.board):
            for j, value in enumerate(row):
                if value == 0:
                    return (i, j)

    def compute_manhattan_distance(self, goal):
        """
        Compute the Manhattan distance heuristic value for this state.

        The Manhattan distance is the sum of the horizontal and vertical distances
        between each tile and its goal position.

        Parameters:
            goal (list of lists): Goal state of the puzzle

        Returns:
            int: Heuristic value (Manhattan distance)
        """
        distance = 0
        for i in range(len(self.board)):
            for j in range(len(self.board[i])):
                value = self.board[i][j]
                if value != 0:  # Skip the empty tile
                    target_x, target_y = divmod(value - 1, len(self.board))
                    distance += abs(i - target_x) + abs(j - target_y)
        self.h = distance

    def is_goal(self, goal):
        """
        Check if this state is the goal state.

        Parameters:
            goal (list of lists): Goal state of the puzzle

        Returns:
            bool: True if this state is the goal state, False otherwise
        """

        return self.board == goal

    def get_neighbors(self):
        """
        Generate neighboring puzzle states by moving the empty tile.

        The function identifies all valid moves of the empty tile (0) within the
        puzzle, creates new states for each move, and returns them as a list.

        Returns:
            list of PuzzleState: A list of neighboring puzzle states generated by
            moving the empty tile in each possible direction (up, down, left, right).
        """
        neighbors = []
        x, y = self.zero_pos
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < len(self.board) and 0 <= ny < len(self.board[0]):
                # Swap the empty tile with the neighbor
                new_board = deepcopy(self.board)
                new_board[x][y], new_board[nx][ny] = new_board[nx][ny], new_board[x][y]
                neighbors.append(PuzzleState(new_board, self.g + 1, self))
        return neighbors

    def __lt__(self, other):
        """
        Compare two PuzzleState objects based on their f(n) values, where
        f(n) = g(n) + h(n). This is used in the priority queue of A* search.
        The state with a lower f(n) value is considered "less than" the other.
        """
        return (self.g + self.h) < (other.g + other.h)

def a_star(start, goal):
    """
    Perform the A* search algorithm to find the shortest path from the start state to the goal state.

    The A* algorithm uses a priority queue to explore states with the lowest estimated cost first. It
    combines the actual cost to reach a state (g) and a heuristic estimate of the cost from the state
    to the goal (h) to determine the priority of each state.

    Parameters:
        start (PuzzleState): The initial state of the puzzle.
        goal (list of lists): The goal state of the puzzle.

    Returns:
        list of lists: A sequence of board states representing the path from the start state to the goal state,
        or None if no solution exists.
    """
    open_set = []
    closed_set = set()
    start.compute_manhattan_distance(goal)
    heapq.heappush(open_set, start)

    while open_set:
        current = heapq.heappop(open_set)

        # Check if goal state is reached
        if current.is_goal(goal):
            return reconstruct_path(current)

        # Add current state to closed set
        closed_set.add(tuple(map(tuple, current.board)))

        # Expand neighbors
        for neighbor in current.get_neighbors():
            if tuple(map(tuple, neighbor.board)) in closed_set:
                continue

            neighbor.compute_manhattan_distance(goal)
            heapq.heappush(open_set, neighbor)

    return None  # No solution found

def reconstruct_path(state):
    """
    Reconstruct the path from the start state to the goal state.

    Given a state, this function follows the parent pointers to reconstruct the
    path from the start state to the goal state.

    Parameters:
        state (PuzzleState): The goal state of the puzzle.

    Returns:
        list of lists: A sequence of board states representing the path from the
        start state to the goal state.
    """

    path = []
    while state:
        path.append(state.board)
        state = state.parent
    return path[::-1]  # Reverse the path

if __name__ == "__main__":
    start_board = [
        [1, 2, 3],
        [4, 0, 5],
        [7, 8, 6]
    ]

    goal_board = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 0]
    ]

    start_state = PuzzleState(start_board)
    goal_state = goal_board
    solution = a_star(start_state, goal_state)

    if solution:
        print("Solution found!")
        for step, board in enumerate(solution):
            print(f"Step {step}:")
            for row in board:
                print(row)
            print()
    else:
        print("No solution exists!")