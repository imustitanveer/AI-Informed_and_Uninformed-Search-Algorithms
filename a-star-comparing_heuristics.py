import heapq

GOAL_STATE = (
    (1, 2, 3),
    (4, 5, 6),
    (7, 8, 0)
)

# Directions for moving the empty space (0)
DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right

class PuzzleState:
    def __init__(self, state, parent=None, move=None, g=0, h=0, heuristic="manhattan"):
        """
        Initialize a PuzzleState object with the given state and parameters.

        Parameters:
            state (tuple of tuples): Current state of the puzzle as a 3x3 grid.
            parent (PuzzleState, optional): Parent state leading to this state (default: None).
            move (tuple, optional): Move that led to this state as (row, column) (default: None).
            g (int, optional): Cost to reach this state, typically the number of moves (default: 0).
            h (int, optional): Heuristic value, calculated based on the chosen heuristic (default: 0).
            heuristic (str, optional): Heuristic method to use, either "manhattan" or "misplaced" (default: "manhattan").
        """
        self.state = state
        self.parent = parent
        self.move = move
        self.g = g
        self.h = h
        self.f = g + h  # f = g + h (total cost)
        self.heuristic = heuristic

    def calculate_heuristic(self):
        """Calculate the heuristic based on the chosen method."""
        if self.heuristic == "manhattan":
            return self.calculate_manhattan()
        elif self.heuristic == "misplaced":
            return self.calculate_misplaced()

    def calculate_manhattan(self):
        """Calculate the Manhattan distance for all tiles."""
        h = 0
        for r in range(3):
            for c in range(3):
                value = self.state[r][c]
                if value != 0:  # Ignore the empty space
                    goal_r, goal_c = (value - 1) // 3, (value - 1) % 3
                    h += abs(r - goal_r) + abs(c - goal_c)
        return h

    def calculate_misplaced(self):
        """Calculate the number of misplaced tiles, compared to the goal state."""
        h = 0
        for r in range(3):
            for c in range(3):
                value = self.state[r][c]
                if value != 0 and value != GOAL_STATE[r][c]:  # Misplaced tile
                    h += 1
        return h

    def get_neighbors(self):
        """
        Generate neighboring puzzle states by moving the empty tile.

        The function identifies all valid moves of the empty tile (0) within the
        puzzle, creates new states for each move, and returns them as a list.

        Returns:
            list of PuzzleState: A list of neighboring puzzle states generated by
            moving the empty tile in each possible direction (up, down, left, right).
        """
        neighbors = []
        empty_r, empty_c = next((r, c) for r in range(3) for c in range(3) if self.state[r][c] == 0)

        for dr, dc in DIRECTIONS:
            new_r, new_c = empty_r + dr, empty_c + dc
            if 0 <= new_r < 3 and 0 <= new_c < 3:
                # Swap the empty space with the adjacent tile
                new_state = [list(row) for row in self.state]
                new_state[empty_r][empty_c], new_state[new_r][new_c] = new_state[new_r][new_c], new_state[empty_r][empty_c]
                neighbors.append(PuzzleState(tuple(tuple(row) for row in new_state), self, (new_r, new_c), self.g + 1, self.calculate_heuristic(), self.heuristic))

        return neighbors

    def __lt__(self, other):
        """
        Compare two PuzzleState objects based on their f(n) values.

        Parameters:
            other (PuzzleState): The other PuzzleState object to compare with

        Returns:
            bool: True if this PuzzleState has a lower f(n) value than other, False otherwise
        """
        return self.f < other.f

def a_star_search(start_state, heuristic="manhattan"):
    """
    Perform A* search algorithm to find the shortest path from the start state to the goal state.

    Parameters:
        start_state (list of lists): The initial state of the puzzle.
        heuristic (str): The heuristic method to use, either "manhattan" or "misplaced".

    Returns:
        tuple: A tuple containing the solution path (list of PuzzleState objects) and the number of node expansions (int),
        or None if no solution exists.
    """
    open_list = []
    closed_list = set()

    start_node = PuzzleState(start_state, heuristic=heuristic)
    heapq.heappush(open_list, start_node)
    node_expansion_count = 0

    while open_list:
        current_node = heapq.heappop(open_list)
        node_expansion_count += 1

        if current_node.state == GOAL_STATE:
            solution_path = []
            while current_node:
                solution_path.append(current_node)
                current_node = current_node.parent
            return solution_path[::-1], node_expansion_count

        if current_node.state in closed_list:
            continue

        closed_list.add(current_node.state)

        for neighbor in current_node.get_neighbors():
            if neighbor.state not in closed_list:
                heapq.heappush(open_list, neighbor)

    return None, node_expansion_count

def print_solution_path(solution_path):
    """Print the solution path."""
    if not solution_path:
        print("No solution found")
        return

    print(f"Solution length: {len(solution_path) - 1}")
    for i, state in enumerate(solution_path):
        print(f"Step {i}:")
        for row in state.state:
            print(row)
        print()

# initial state for the 8-puzzle (3x3)
initial_state = (
    (1, 2, 3),
    (4, 5, 6),
    (0, 7, 8)
)

# Run A* with Manhattan Heuristic
print("Running A* with Manhattan Heuristic...")
solution_path_manhattan, nodes_expanded_manhattan = a_star_search(initial_state, heuristic="manhattan")
print_solution_path(solution_path_manhattan)
print(f"Nodes expanded (Manhattan): {nodes_expanded_manhattan}\n")

# Run A* with Misplaced Tile Heuristic
print("Running A* with Misplaced Tile Heuristic...")
solution_path_misplaced, nodes_expanded_misplaced = a_star_search(initial_state, heuristic="misplaced")
print_solution_path(solution_path_misplaced)
print(f"Nodes expanded (Misplaced Tile): {nodes_expanded_misplaced}")
